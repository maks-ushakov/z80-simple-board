.engine simple_board
.binto ENDAPP
; Simplest OS (Monitor)
;
; Registers
; HL - address
; C - data
; End your program with HALT to stop board
; OR RST 38 (FF) to return in Monitor

DISPLAY_PORT: 	equ 0x1 	; Data byte indicator
KBD_PORT: equ 0x1

STATUS_PORT: equ 0x00
STATUS_AWAIL: equ 0x20

LAST_RAM: equ 200H ; First unavailable RAM cell
FIRST_RAM: equ 0100H; First available RAM cell

;Key kodes
C_SETHB: equ 'H'  ;  Hight ADDR byte
C_SETLB: equ 'L'  ; Low ADDR byte
C_SETDAT: equ 'M' ; DATA
C_RUN: equ 'G'	 ; Run code

org 0
di
jr start

; setup()
.org 0x0038
start:
	; First unavailable memory cell to set Stack Pointer
	ld sp, LAST_RAM 	; sp <- LAST_RAM 
	ld hl, FIRST_RAM	; hl <- FIRST_RAM Current Address
; loop()
display:	
							; Show Address from HL
							; Save data from memory to C
	ld c, (hl)				; c <- memory data pointed in HL
display_addr:
	ld a, h					; A <- H , Get High byte of address
    call print_byte
	ld a, l					; A -< L , Get low byte of address
	call print_byte
	ld a, ' '
	out (DISPLAY_PORT), a
display_data:
	ld a, c					; A <- C , Get saved data
	call print_byte
	ld a, '\n'
	out (DISPLAY_PORT), a
	ld a, '\r'
	out (DISPLAY_PORT), a
main:
scan_kbd:
	in A, (KBD_PORT)	    ; Skan KBD, result (Keycode) in A
	; Process key
	cp '0'					;
	jp m, non_digit	        ; if A < 30H, continue on non_digit
	cp 'F' + 1
	jp p, non_digit         ; if A > 'F'
	cp 'A'
	jp m, end_scaning
	sub 0x07
end_scaning:
	and 0fh
	ld b, a					; B <- A
	ld a, c					; A <- C
	rlca					; Roll A 4 times
	rlca
	rlca
	rlca
	and 0f0h				; A = A & 0xF0
	or b					; A = A | B
	ld c, a					; C <- A
	jr display_data		    ; Display
	
non_digit:
	cp C_SETHB				; 
	jr nz, set_low_addr     ; if Key != SET_HB, check SET_LB
	ld h, c					; H <- C, Load to Addr H reg
	jr display
	
set_low_addr:
	cp C_SETLB				;
	jr nz, set_instr	    ; if Key != SET_LB, check SET_DAT
	ld l, c					; L <- C, Load to Addr Low reg
	jr display

set_instr:
	cp C_SETDAT				;
	jr nz, run				; if Key != SET_DAT, check RUN
	; load from C to memory cell pointed from HL
	ld (hl), c				; (HL) <- C	
	inc hl					; HL++
	jr display

run:
	cp C_RUN
	jr nz, main				; if Key != RUN, check again
	jp (hl)					; Execute code
	
	; Put Printed HEX value into reg. A
print_byte:
    ld b, a                 ; temporary Save value
	rrca                    ; Get higher half of byte
	rrca
	rrca
	rrca
    call print_symbol       ; Show hight part of HEX value
	ld a, b                 ; restire original value
	and 0x0f                ; lower half mask
	call print_symbol
	ret                     ; return to caller
	
print_symbol:
	and 0x0f                ; Half byte mask
	or 0x30                 ; turn into ASCII char 
	cp 0x39+1
	jp m, print             ; if value < '9', print
	add a, 0x07             ; else make some correction
print:	
    out (DISPLAY_PORT), a   ; send to serial port
	ret
    
    halt
ENDAPP:
    nop
